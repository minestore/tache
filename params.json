{"name":"Tache","tagline":"Full spec-compliant Mustache implementation with 'safe views' for end user applications.","body":"# Tache\r\n## Full Mustache implementation plus 'safe views'.\r\n\r\nTache is a **full spec-compliant [Mustache](http://mustache.github.com/) implementation** with the *addition* of 'safe views'.\r\n\r\nSafe views allow Tache templates to be edited by end users, without the risk jeopardising your application's security. When using safe views, only explicitly allowed methods are ever invoked and therefore calls to potentially destructive methods such as 'eval' or 'destroy' are ignored.\r\n\r\n#### Now with RubyMotion support.\r\n\r\n## Usage\r\n\r\nTache's safe views are an opt-in feature, so Tache will behave just as you'd expect a standard Mustache implementation to behave, unless *you* say otherwise.\r\n\r\n### Standard Views\r\n\r\nQuick example:\r\n\r\n```ruby\r\nrequire 'tache'\r\n\r\nTache.render('Hello {{planet}}', 'planet' => 'World')\r\n\r\n=> \"Hello World\"\r\n```\r\n\r\nPlease note that all hash keys must be defined as strings when working with any Tache view. This minimises the risk of memory leaks caused by symbols when used in an end-user environment and is therefore a general requirement of Tache, regardless of whether or not you are using safe views.\r\n\r\nHere's another way of doing things (no real departure from standard Mustache):\r\n\r\n```ruby\r\nclass MyView < Tache\r\n  def planet\r\n    'World'\r\n  end\r\n  \r\n  def star\r\n    '*'\r\n  end\r\n  \r\n  def stars\r\n    star * 5\r\n  end\r\nend\r\n\r\nview = MyView.compile(\"{{planet}} (rating: {{stars}})\")\r\nview.render\r\n```\r\n    \r\nResult:\r\n\r\n    World (rating: *****)\r\n\r\n### Safe Views\r\n\r\nIn order make use of Tache's safe views, you simply use `Tache::Safe` instead:\r\n\r\n```ruby\r\nrequire 'tache/safe'\r\n\r\nTache::Safe.render('Hello {{planet}}', 'planet' => 'World')\r\n=> \"Hello World\"\r\n```\r\n    \r\nThe first thing you will notice about safe views (other than them looking a lot like unsafe views), is that only values that have been explicitly exposed via safe view methods will be invoked. Therefore anything that has not been explicitly exposed will not be invoked or output to the rendered template:\r\n\r\n```ruby\r\nTache::Safe.render('Hello {{planet.inspect}}', 'planet' => 'World')\r\n=> \"Hello \"\r\n```\r\n\r\nAnother example, this time subclassing `Tache::Safe`:\r\n\r\n```ruby\r\nclass MySafeView < Tache::Safe\r\n  def thing\r\n    'World'\r\n  end\r\n\r\n  def present\r\n    \"I'm here!\"\r\n  end\r\n\r\n  def bold\r\n    lambda do |text|\r\n      '<b>' + render(text) + '</b>'\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nTemplate:\r\n\r\n    Hello {{thing}}, here's safe view in action:\r\n\r\n    self            -> {{.}}\r\n    inspect         -> {{inspect}}\r\n    to_sym          -> {{to_sym}}\r\n    thing           -> {{thing}}\r\n    present         -> {{present}}\r\n    present.upcase  -> {{present.upcase}}\r\n\r\n    Bold: {{#bold}}{{thing}}{{/bold}}\r\n\r\nRender:\r\n\r\n```ruby\r\nview = MySafeView.compile(template)\r\nview.render\r\n```\r\n   \r\nResult:\r\n\r\n    Hello World, here's safe view in action:\r\n\r\n    self            -> \r\n    inspect         -> \r\n    to_sym          -> \r\n    thing           -> World\r\n    present         -> I'm here!\r\n    present.upcase  -> \r\n\r\n    Bold: <b>World</b>\r\n  \r\nNotice how lambda's still work just as you'd expect but only explicitly exposed values are in the rendered output.\r\n\r\nSo, what if we want to expose something other than hash values or view object methods to our templates? Just subclass `Tache::Safe` and you're good to go, it's turtles all the way down:\r\n\r\nExample:\r\n\r\n```ruby\r\nclass Product\r\n  def title\r\n    'iPhone'\r\n  end\r\n\r\n  def price\r\n    399\r\n  end\r\n\r\n  def destroy\r\n    'Deleted product from database!'\r\n  end\r\n\r\n  # Returns product from database\r\n  def self.first\r\n    Product.new\r\n  end\r\nend\r\n\r\nclass ProductView < Tache::Safe\r\n  def initialize(product)\r\n    @product = product\r\n  end\r\n\r\n  def title\r\n    @product.title\r\n  end\r\n\r\n  def price\r\n    \"$#{@product.price}\"\r\n  end\r\nend\r\n\r\nclass CartView < Tache::Safe\r\n  def product\r\n    ProductView.new(Product.first)\r\n  end\r\nend\r\n```\r\n\r\nTemplate:\r\n\r\n    Product price: {{product.price}}\r\n    Trying to destroy: {{product.destroy}}\r\n\r\n    {{^destroy}}Bad luck hacker!{{/destroy}}\r\n\r\nRender:\r\n\r\n```ruby\r\nview = CartView.compile(template)\r\nview.render\r\n```\r\n\r\nResult:\r\n\r\n    Product price: $399\r\n    Trying to destroy: \r\n\r\n    Bad luck hacker!\r\n\r\n###Safe view shortcut\r\n\r\nIt can become monotonous having to create a safe view class for any object you would like to expose to a template, therefore Tache also provides a shortcut for creating safe views from existing objects.\r\n\r\nSimply include the `Tache::Safe::Auto` module and call the `tache` class method, supplying it with a list of methods you would like to be available in your templates and Tache will dynamically create a safe view for you behind the scenes:\r\n\r\n```ruby\r\nclass Person\r\n  include Tache::Safe::Auto\r\n\r\n  tache :name, :occupation\r\n  \r\n  def name\r\n    'Jamie'\r\n  end\r\n  \r\n  def occupation\r\n    'Developer'\r\n  end\r\n  \r\n  def age\r\n    \"Don't ask\"\r\n  end\r\nend\r\n```\r\n    \r\nTemplate\r\n\r\n    {{#person}}\r\n    Name: {{name}}\r\n    Occupation: {{occupation}}\r\n    Age: {{age}}\r\n    {{/person}}\r\n    \r\nRender\r\n  \r\n```ruby\r\nTache::Safe.render(template, { 'person' => Person.new })\r\n```\r\n    \r\nResult\r\n    \r\n    Name: Jamie\r\n    Occupation: Developer\r\n    Age: \r\n\r\n### Compiled templates and partials\r\n\r\nProper documentation on compiled templates and partials coming soon! For now, just see the code (it's pretty straight forward):\r\n\r\n```ruby\r\n# Compiled\r\ncompiled = MyView.compile('Hello {{thing}}')\r\ncompiled.render\r\n\r\n# Partials\r\nTache::Safe.render('Hello {{>partial}}', { 'a' => 'b' }, { 'partial' => 'World' })\r\n\r\n# Both\r\ncompiled = MyView.compile('Hello {{>partial}}')\r\ncompiled.partials['partial'] = 'World\r\ncompiled.render\r\n```\r\n    \r\nYou can even precompile a punch of partials (they'll get compiled for you automatically anyway but handy to know):\r\n\r\n```ruby\r\ncompiled = MyView.compile('Hello {{>partial1}}, {{>partial2}}')\r\ncompiled.partials = { \r\n  'partial1' => Tache::Template.compile('{{a.b.c}}'),\r\n  'partial2' => Tache::Template.compile('{{a.b.c.d}}')\r\n}\r\ncompiled.render\r\n```\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'tache'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install tache\r\n\r\nNote: Tache requires at least Ruby 1.9.\r\n\r\n### RubyMotion\r\n\r\nAs above, then just require it in your Rakefile:\r\n\r\n    require 'tache'\r\n\r\n## Testing\r\n\r\nTests are written with Test::Unit and can be run with Guard:\r\n\r\n    bundle\r\n    bundle exec guard   \r\n\r\n## Acknowledgements\r\n\r\nThanks to [Chris Wanstrath](https://github.com/defunkt) for the original Ruby implementation and [Jan Lehnardt](https://github.com/janl) for his JavaScript port (I took a great deal of inspiration, understanding and tests from this version).\r\n\r\nThanks also to the guys at [Shopify](https://github.com/Shopify) for their `Liquid::Drop` inspiration and [Gwendal Rou√©](https://github.com/groue) for putting up with my brainstorming on GitHub.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}